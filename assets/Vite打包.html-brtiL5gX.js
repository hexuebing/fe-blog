import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as i,f as t}from"./app-N74RJCnI.js";const r={},n=t('<h1 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> Vite</h1><h2 id="为什么vite比webpack要快" tabindex="-1"><a class="header-anchor" href="#为什么vite比webpack要快" aria-hidden="true">#</a> 为什么Vite比webpack要快</h2><ul><li><p><strong>ES Module支持</strong>，利用现代浏览器对ES Module的原生支持，可以直接在浏览器中运行未经过打包的ES Module代码，而不需要像Webpack那样将所有代码打包成一个或多个bundle文件。这样可以减少打包时间</p></li><li><p><strong>按需编译</strong>，Vite在开发模式下会根据需要动态编译单个文件，而不是像Webpack那样每次都重新编译整个项目，这样在修改文件时，只会重新编译修改的文件</p></li><li><p><strong>按需加载</strong>：在HMR（热更新）方面，当改动了一个模块后，vite 仅需让浏览器重新请求该模块即可，不像 webpack 那样需要把该模块的相关依赖模块全部编译一次，效率更高。</p></li></ul><p>webpack 是先打包再启动开发服务器，vite 是直接启动开发服务器，然后按需编译依赖文件。由于 vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。</p><h2 id="vite对比webpack-优缺点" tabindex="-1"><a class="header-anchor" href="#vite对比webpack-优缺点" aria-hidden="true">#</a> vite对比webpack，优缺点</h2><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ul><li>更快的冷启动： Vite 借助了浏览器对 ESM 规范的支持，采取了与 Webpack 完全不同的 unbundle 机制</li><li>更快的热更新： Vite 采用 unbundle 机制，所以 dev server 在监听到文件发生变化以后，只需要通过 ws 连接通知浏览器去重新加载变化的文件，剩下的工作就交给浏览器去做了。</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><ul><li><p><strong>开发环境下首屏加载变慢</strong>：由于 unbundle 机制， Vite 首屏期间需要额外做其它工作。不过首屏性能差只发生在 dev server 启动以后第一次加载页面时发生。之后再 reload 页面时，首屏性能会好很多。原因是 dev server 会将之前已经完成转换的内容缓存起来</p></li><li><p><strong>webpack支持的更广</strong>：由于 Vite 基于ES Module，所以代码中不可以使用CommonJs；webpack更多的关注兼容性, 而 Vite 关注浏览器端的开发体验。</p></li></ul>',9),d=[n];function l(c,o){return a(),i("div",null,d)}const p=e(r,[["render",l],["__file","Vite打包.html.vue"]]);export{p as default};
